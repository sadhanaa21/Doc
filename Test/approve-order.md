# Approve Order

## Requirement

For order approval, a verification check is necessary to confirm the presence of specific attributes linked to the given order ID.&#x20;

An order qualifies for approval only when it possesses both the NETSUITE\_ORDER\_EXPORTED and RX\_PRODUCT\_VERIFIED attributes.

## Implementation

The process to approve eligible orders will be managed by NiFi. The entire workflow is divided into six segments:

1. Order Attribute for NetSuite exported Orders
2. Order Attribute for orders with RX products
3. Order Attribute for orders without RX products
4. Approve Order

To establish OrderAttributes, a CSV file will be generated, serving as input for the HC job to produce or import corresponding data. Subsequently, eligible orders for the approval feed will be retrieved, and the HC job will be used to approve these orders.

<details>

<summary>NiFi flow</summary>

**All process groups except **_**Order Attribute for order having RX products**_

1. All the process group except **Order Attribute for order having RX products** have exact same flow but the SQL query differs.
2. The **ExecuteSQLRecord** processor is employed to execute a SQL query, resulting in the generation of a CSV file according to the defined Avro schema.
3. The subsequent processor is **RouteOnAttribute**, where a check is performed to determine whether the flow file contains any records.
4. Following that, the filename is updated to the required format using the **UpdateAttribute** processor.
5. The final step involves transferring the file to the SFTP location using the **PutSFTP** processor.
6. These kept files will be consumed via HC to create order attributes.

**Process group Order Attribute for all 319 POS Orders having RX products -**

1. The **ExecuteSQLRecord** processor is utilized to execute a SQL query.
2. The flow is then split into individual JSON documents using the **Split JSON** Processor. These JSON documents serve as the request body for an API call.
3. A POST request is sent for each JSON document to the specified API endpoint through the **Invoke HTTP** Processor.
4. The response returned from the **Invoke HTTP** Processor is directed to the **RouteOnAttribute** Processor.
5. This processor has two dynamic properties defined: Failure and Success. Any statusCode except 200 is considered a failure.
6. Based on these properties, three relations are established:
   * Success
   * Failure
   * Failure, Success, and Unmatched. This encloses all flow files, irrespective of the API call's response.
7. For the Failure, Success, and Unmatched relations, the subsequent processor is **UpdateRecord**, which appends a response corresponding to the orderId in the flow file.
8. The next step involves using the **MergeRecord** processor, configured with the Merge Strategy as Defragment, which waits until the fragment count becomes equal.
9. For all the failure and original relations from **MergeRecord**, there is a **Notify**.
10. And for all merged relations, there is **UpdateAttribute**, followed by **PutSFTP** in a sub-directory named "http\_log".
11. For the Failure relations, the subsequent processor is **Wait**, which waits until the Notify notifies it.
12. Following that, there is **UpdateRecord**, which adds the orderId and its corresponding response generated by the API call.
13. All the failure flow files are then merged and placed in a directory with a sub-directory named "http\_error\_log".
14. For the Success relation, there is also a **Wait**, which waits until the Notify notifies it.
15. Subsequently, the flow files are merged using the **MergeRecord** processor, utilizing the required Avro schema for data writing.
16. The merged file name is updated using **UpdateAttribute** and placed on the SFTP server using the **PutSFTP** processor.

</details>
